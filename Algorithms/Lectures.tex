%% LyX 2.1.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[russian]{article}
\usepackage[T2A,T1]{fontenc}
\usepackage[cp1251]{inputenc}
\usepackage{geometry}
\geometry{verbose,tmargin=2cm,bmargin=2cm,lmargin=1cm,rmargin=1cm}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage{amssymb}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\cyrtext}{%
  \fontencoding{T2A}\selectfont\def\encodingdefault{T2A}}
\DeclareRobustCommand{\textcyr}[1]{\leavevmode{\cyrtext #1}}
\AtBeginDocument{\DeclareFontEncoding{T2A}{}{}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
  \theoremstyle{definition}
  \newtheorem{defn}{\protect\definitionname}[section]
  \theoremstyle{remark}
  \newtheorem{claim}{\protect\claimname}[section]
  \theoremstyle{plain}
  \newtheorem{lyxalgorithm}{\protect\algorithmname}
  \theoremstyle{remark}
  \newtheorem{rem}{\protect\remarkname}[section]
  \theoremstyle{definition}
  \newtheorem{xca}{\protect\exercisename}[section]
  \theoremstyle{plain}
  \newtheorem{thm}{\protect\theoremname}[section]
  \theoremstyle{definition}
  \newtheorem{example}{\protect\examplename}[section]
  \theoremstyle{definition}
  \newtheorem{problem}{\protect\problemname}[section]
\newenvironment{lyxcode}
{\par\begin{list}{}{
\setlength{\rightmargin}{\leftmargin}
\setlength{\listparindent}{0pt}% needed for AMS classes
\raggedright
\setlength{\itemsep}{0pt}
\setlength{\parsep}{0pt}
\normalfont\ttfamily}%
 \item[]}
{\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage[all]{xy}
\usepackage{pgf,tikz}
\usepackage{mathrsfs}
\usetikzlibrary{arrows}

\makeatother

\usepackage{babel}
\usepackage{listings}
  \providecommand{\algorithmname}{Алгоритм}
  \providecommand{\claimname}{Утверждение}
  \providecommand{\definitionname}{Определение}
  \providecommand{\examplename}{Пример}
  \providecommand{\exercisename}{Упражнение}
  \providecommand{\problemname}{Проблема}
  \providecommand{\remarkname}{Замечание}
\providecommand{\theoremname}{Теорема}
\renewcommand{\lstlistingname}{Листинг}

\begin{document}

\title{Алгоритмы и структуры данных}

\maketitle

\part{Геометрические алгоритмы}


\section{$\mathsection30.$ Выпуклая оболочка в $2D$}

В данном параграфе будет рассмотрена задача нахождения выпуклой оболочки
некоторого множества точек на плоскости.
\begin{defn}
Выпуклой оболочкой множества точек $X$ в некотором аффинном пространстве
$\mathcal{A}$ называется минимальное по включению множество точек
$ConvexHull(X)\mbox{\ensuremath{\supseteq}X}.$ Из курса линейной
алгебры известно, что данное множество существует для любого ограниченного
множества $X$.
\end{defn}
Можно заметить, что если множество $X$ является конечным, то множество
$ConvexHull(X)$ является многоугольником. Нашей задачей является
нахождение выпуклой оболочки конечного множества $X$, состоящего
из конечного числа точек (обозначим через $n=|X|$), в частности,
нахождение вершин множества $\partial(ConvexHull(X))$ и их последующее
упорядочивание в порядке следования в полученном многоугольнике.

Напомним основные операции, применимые к векторам в пространстве $\mathbb{R}^{3}$:
\begin{defn}
Скалярным произведением векторов $\overrightarrow{u}$ и $\overrightarrow{v}$
в пространстве $\mathbb{R}^{3}$ называется число $(\overrightarrow{u},\overrightarrow{v})=u_{x}v_{x}+u_{y}v_{y}+u_{z}v_{z}$.
\end{defn}

\begin{defn}
Векторным произведением векторов $\overrightarrow{u}$ и $\overrightarrow{v}$
в пространстве $\mathbb{R}^{3}$ называется вектор $[\overrightarrow{u},\overrightarrow{v}]=det\left(\begin{array}{ccc}
i & j & k\\
u_{x} & u_{y} & u_{z}\\
v_{x} & v_{y} & v_{z}
\end{array}\right)$, направление вектора (в геометрическом определении) определяется
по направлению наименьшего угла поворота от вектора $\overrightarrow{u}$
к вектору $\overrightarrow{v}$.\end{defn}
\begin{claim}
$[\overrightarrow{u},\overrightarrow{v}]\bot\overrightarrow{u},$
$[\overrightarrow{u},\overrightarrow{v}]\bot\overrightarrow{v}$.
\end{claim}

\begin{claim}
$[\overrightarrow{u},\overrightarrow{v}]=|\overrightarrow{u}|\cdot|\overrightarrow{v}|\cdot|sin\alpha|$
\end{claim}


Рассмотрим некоторые алгоритмы, решающие задачу нахождения выпуклой
оболочки точек в двумерном пространстве.
\begin{lyxalgorithm}
Алгоритм Джарвиса (алгоритм ``заворачивания подарка'') - \textbf{Jarvis,
1973.}

Ход алгоритма:\end{lyxalgorithm}
\begin{enumerate}
\item Выберем самую нижнюю точку из исходного множества точек $P$, а среди
самых нижних точек --- самую левую (т.е. наименьшую по координате
$Ox$). Обозначим полученную точку через $c_{0}$.
\item Выбираем точку с наименьшим углом поворота относительно предыдущего
отрезка. Для сравнения точек по полярному углу воспользуемся знаком
векторного произведения. При равенстве углов поворота возьмем вектор,
имеющий большую длину. Обозначим полученную точку (на $k$-ой итерации
шага (2)) через $c_{k}$. Повторяем шаг (2) до тех пор, пока не будет
выполнено равенство $c_{l}=c_{0}$ для некоторого $l\in\mathbb{N}$.
\end{enumerate}
Время работы данного алгоритма --- $O(nh)$, где $n$--- количество
точек в исходном множестве $X$, а $h$ --- количество вершин в многоугольнике
$\partial ConvexHull(X)$.

Как видно, сложность алгоритма Джарвиса может достигать оценки $O(n^{2})$,
поэтому приведем другой алгоритм построения выпуклой оболочки множества
точек $X$.

\bigskip


\section{$\mathsection31.$ Выпуклая оболочка в $3D$}

В данном параграфе будут рассмотрены алгоритмы построения выпуклой
оболочки множества точек в $\mathbb{R}^{3}$. Чтобы найти выпуклую
оболочку конечного количества точек, необходимо и достаточно построить
выпуклый многогранник, содержащий данное множество точек.
\begin{rem}
Будем считать, что никакие четыре точки не лежат в одной плоскости
(иначе данную грань можно триангули-ровать любой треугольник).\end{rem}
\begin{lyxalgorithm}
Построение выпуклой оболочки методом полного перебора.

Перебираем все точки множества $p_{1},\ p_{2},\ p_{3}$. Проверяем,
является ли грань внешней: $\overrightarrow{n}=\overrightarrow{p_{1}p_{2}}\times\overrightarrow{p_{1}p_{3}}$
(проверим, что грань торчит наружу). Такой алгоритм имеет сложность
$O(n^{4})$. \end{lyxalgorithm}
\begin{rem}
Заметим, что данный алгоритм обобщается на случай $\mathbb{R}^{k}$
и будет работать за $O(n^{k+1}k^{3})$. Чтобы проверить ориентацию,
надо будет проверить знак определителя $det\left(\begin{array}{c}
\overrightarrow{pp_{1}}\\
\overrightarrow{pp_{2}}\\
\overrightarrow{pp_{3}}\\
\dots\\
pp_{k-1}
\end{array}\right)$. 
\end{rem}
Принадлежность точки плоскости можно проверить следующим образом:
$det\left(\begin{array}{ccc}
x-x_{1} & y-y_{1} & z-z_{1}\\
x_{2}-x_{1} & y_{2}-y_{1} & z_{2}-z_{1}\\
x_{3}-x_{1} & y_{3}-y_{1} & z_{3}-z1
\end{array}\right)=0$. Тогда уравнение плоскости имеет вид $Ax+By+Cz+D=0$, где $\overrightarrow{n}=\left(\begin{array}{c}
A\\
B\\
C
\end{array}\right)$ --- вектор нормали. Таким образом, надо проверить знак скалярного
произведения. Сложность алгоритма умножается на $k^{3}$ из-за вычисления
определителя матрицы.
\begin{lyxalgorithm}
Алгоритм построения методом заворачивания подарка. 

Ход алгоритма:\end{lyxalgorithm}
\begin{enumerate}
\item Находим точку $p_{0}$ с минимальной координатой по оси $z$. Данный
шаг выполняется за $O(n)$.
\item Находим точку $p_{1}$, для которой выполняется следующее условие:
$\angle(\overrightarrow{p_{0}p_{1}},\mbox{\ensuremath{\overrightarrow{Oz}}})$
максимален. Данный шаг выполняется за $O(n)$.
\item Нахождение первой грани: рассмотрим множество треугольников $\Delta pp_{0}p_{1}$,
среди них необходимо выбрать такую точку $p$, что все остальные точки
лежат в одной стороне относительно плоскости $p_{0}p_{1}p$. Выполняется
аналогично алгоритму Джарвиса в двумерном случае (или вычисляется
максимальный угол раскрытия или наибольший угол между осью $Oz$ и
$\overrightarrow{n}=\overrightarrow{p_{0}p_{1}}\times\mbox{\ensuremath{\overrightarrow{p_{0}p_{2}}}}$).
Данный шаг выполняется за $O(n^{2})$. 
\item Поиск грани от некоторого ``незакрытого'' ребра $\overrightarrow{p_{k}p_{k+1}}$:
ищем ту точку, для которой угол между нормалями граней минимальна.
Но существует проблема: мы могли закрыть некоторые смежные грани:
закрываем от 1 до 3 граней. Главное --- записать информацию об открытости/закрытости
ребер. В конце данной итерации надо открыть новые ребра. Далее будет
доказано, что количество открытых ребер и количество граней равняется
$O(n)$.
\end{enumerate}
В итоге, из того, что количество итераций шага (4) равно $O(n)$,
и алгоритм 31.2 работает за $O(n^{2})$. Осталось доказать следующее
утверждение:
\begin{claim}
Граф выпуклой оболочки является планарным. При этом количество ребер
в выпуклой оболочке равняется $O(n)$.\end{claim}
\begin{proof}
Доказывается непосредственным применением формулы Эйлера для планарного
графа.\end{proof}
\begin{lyxalgorithm}
Алгоритм построения выпуклой оболочки методом ``divide and conquer''

Разобьем вертикальными плоскостями множества точек на группы из 5-7
точек (в лексикографическом порядке). Строим выпуклую оболочку точек
каждой группы тривиальным алгоритмом. Заметим, что полученные выпуклые
многогранники не пересекаются.

Покажем, как можно объединить две выпуклые оболочки за объём времени,
равный O(n). Обозначим через $P,Q$ --- исходные многранники. На идейном
уровне: если сделать проекцию многогранников на ось $Oxy$, то получим
два непересекающихся многоугольника. Построим для проекций объединение
выпуклых оболочек за O(n) времени. Запомним ``крайнее ребро'' при
объединении (обозначим данное ребро через $p_{1}q_{1}$). Воспользуемся
аналогом алгоритма ``заворачивания подарка''. Заметим, что ребро
$p_{1}q_{1}\in\partial(ConvexHull(P\cup Q))$. Относительно данного
ребра будем заворачивать выпуклую оболочку точек. Рассмотрим такую
точку $x$, что все точки лежат по одну сторону от плоскости $p_{1}q_{1}x$
(можно считать наименьший угол между нормалью к плоскости $p_{1}q_{1}x$
и осью Oy). Единственной проблемой является выбор следующей грани.
Далее необходимо выбирать множество точек таким образом, чтобы ``параллельно''
идти по множествам точек $\partial P$ и $\partial Q$. Покажем, как
решить данную проблему. Действительно, можно минимизировать угол между
нормалями. В конце алгоритма осталось выкинуть точки $Inn(ConvexHull(P\cup Q))$.

В качестве структуры для хранения граней можно использовать граф.
В данном графе можно выкидывать лишние ребра. При этом можно еще выкидывать
соответствующие точки из проекций. При помощи DFS можно пометить обход,
по которым обходит объединение.

В итоге, все итерации объединения будут работать за O(n). Действительно,
по каждое ребро мы рассматриваем не более 2 раза (а количество ребер,
как было доказано в \textbf{утверждении 1}, равняется $O(n)$). Таким
образом, суммарное время работы алгоритма составляет O(n(logn)).\end{lyxalgorithm}
\begin{xca}
Придумать улучшение данного алгоритма для многомерного случая.

\bigskip
\end{xca}

\section{$\mathsection32$. Алгоритмы вычислительной геометрии}
\begin{lyxalgorithm}
Алгоритм поиска ближайших точек в $2D$. 

На плоскости надо найти пару точек с наименьшим расстоянием. Будем
использовать метод ``разделяй и влавствуй''. Для этого разделим
множество точек на две части вертикальной прямой (обозначим их через
$A_{1}$ и $A_{2}$). В каждой из них найдем минимальную пару точек
на расстояниях $h_{1}$ и $h_{2}$ соответственно. Обозначим через
$h=min(h_{1},h_{2}).$ Тогда новое минимальное расстояние может быть
в полосе $B=\{p_{i}:\ |p_{i}.x-x|\le h\}$. Тогда будем искать пару
в $B$ за $O(n)$. Рассмотрим множество $C_{i}=\{p_{j}:\ p_{j}\in B,\ p_{i}.y-h\le p_{j}.y<p_{i}.y\}$.
Тогда утверждается, что $|C_{i}|\le7$. Если отсортировать все точки
по координате $y$, то тогда можно выбирать все точки $p_{i}\in B$
(можно данную вещь прокрутить через очередь точек, находящихся в множестве
$B$, и лежащих на расстоянии не более $h$).

В итоге, алгоритм будет работать за время, равное $O(n\log n)$ .
\end{lyxalgorithm}

\begin{lyxalgorithm}
Алгоритм поиска треугольника с наименьшим периметром выполняется аналогичным
образом.

Отсортируем все точки по $x$-координате.\end{lyxalgorithm}
\begin{enumerate}
\item Разделяем множества точек на множества $A_{1}$ и $A_{2}$, в каждом
их которых рекурсивно вызывается алгоритм. Аналогичным образом отсортируем
все точки по координате $y$.
\item Обозначим периметры минимальных треугольников через $l_{1}$ и $l_{2}$
соответственно, $l=min(l_{1},\ l_{2})$. Далее обозначим полосу $B$
шириной $l$ (этого хватит, ибо наибольшая сторона треугольника тогда
не более $l/2$). Далее будем пойти по блоку высоты $l/2$. Утверждается,
что в таком блоке ограниченное количество точек (на самом деле, не
более 16)
\end{enumerate}
\definecolor{uuuuuu}{rgb}{0.26666666666666666,0.26666666666666666,0.26666666666666666} \definecolor{sqsqsq}{rgb}{0.12549019607843137,0.12549019607843137,0.12549019607843137} \definecolor{xdxdff}{rgb}{0.49019607843137253,0.49019607843137253,1.} \definecolor{qqqqff}{rgb}{0.,0.,1.} \begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=1.0cm,y=1.0cm] \clip(-6.097555047582588,-4.037915463112448) rectangle (8.905465549009254,5.261389029354241); \draw (0.,-4.037915463112448) -- (0.,5.261389029354241); \draw (-2.6731851539239653,3.17466362540602) node[anchor=north west] {$A_1$}; \draw (2.816507831847515,3.0997555339822376) node[anchor=north west] {$A_2$}; \draw [dash pattern=on 3pt off 3pt] (-1.7910664964851497,-4.037915463112448) -- (-1.7910664964851497,5.261389029354241); \draw [dash pattern=on 3pt off 3pt] (1.798684897719487,-4.037915463112448) -- (1.798684897719487,5.261389029354241); \draw (0.33383965894501305,2.9178358833816236) node[anchor=north west] {$B$}; \draw (-1.1001152340245355,-1.0308906502434725) node[anchor=north west] {$l/2$}; \draw (1.798684897719487,0.33368954351771585)-- (-0.006339386522219928,0.35481273069323815); \draw (-1.7910664964851497,-1.0695111219503957)-- (0.,-1.069663794122845); \draw (-1.7910664964851497,1.1703257358478991)-- (1.798684897719487,1.1703257358478991); \draw (0.7297824278992914,0.9381220386102339) node[anchor=north west] {$l/2$}; \begin{scriptsize} \draw [fill=qqqqff] (0.,-3.5) circle (1.5pt); \draw[color=qqqqff] (0.0770119169206163,-3.353041484380724) node {$B$}; \draw [fill=qqqqff] (-1.7910664964851497,-1.9421446639167192) circle (1.5pt); \draw[color=qqqqff] (-1.7207822772501609,-1.7906727203989787) node {$C$}; \draw [fill=qqqqff] (1.798684897719487,-1.8351331047398873) circle (1.5pt); \draw[color=qqqqff] (1.8748061110913934,-1.6836611612221468) node {$D$}; \draw [fill=xdxdff] (-1.7910664964851497,1.1703257358478991) circle (1.5pt); \draw[color=xdxdff] (-1.7207822772501609,1.3233636516468288) node {$E$}; \draw [fill=sqsqsq] (-0.006339386522219928,0.35481273069323815) circle (1.5pt); \draw[color=sqsqsq] (0.06631076100293311,0.4993746459852232) node {$G$}; \draw [fill=xdxdff] (1.798684897719487,0.33368954351771585) circle (1.5pt); \draw[color=xdxdff] (1.8748061110913934,0.48867349006754) node {$H$}; \draw [fill=xdxdff] (-1.7910664964851497,-1.0695111219503957) circle (1.5pt); \draw[color=xdxdff] (-1.7207822772501609,-0.9238790910666407) node {$I$}; \draw [fill=xdxdff] (0.,-1.069663794122845) circle (1.5pt); \draw[color=xdxdff] (0.0770119169206163,-0.9238790910666407) node {$J$}; \draw [fill=uuuuuu] (1.798684897719487,1.1703257358478991) circle (1.5pt); \draw[color=uuuuuu] (1.8748061110913934,1.3233636516468288) node {$F$}; \draw[color=black] (0.034207293249883516,1.0879382214577986) node {$d$}; \draw [fill=uuuuuu] (0.0038092006171686066,1.1703257358478991) circle (1.5pt); \draw[color=uuuuuu] (0.0770119169206163,1.3233636516468288) node {$K$}; \end{scriptsize} \end{tikzpicture}
\begin{lyxalgorithm}
Поиск диаметра точек на плоскости.\end{lyxalgorithm}
\begin{defn}
Опорной прямой к фигуре $\Phi$ называется прямая $l$, параллельная,
касательная к фигуре $\Phi$, такая что $\Phi$ лежит в одной полуплоскости
относительно $\Phi$.\end{defn}
\begin{claim}
Пусть $L_{1}$ и $L_{2}$ --- параллельные опорные прямые в точках
$A_{1}$ и $A_{2}$, при этом расстояние между $L_{1}$ и $L_{2}$
максимально. Тогда $A_{1}A_{2}\bot L_{1}$, $A_{1}A_{2}\bot L_{2}$\end{claim}
\begin{proof}
Предположим противное. Тогда рассмотрим прямые $L_{1}',L_{2}'\bot A_{1}A_{2}$.
Тогда доведем их до опорных и получим противоречие.\end{proof}
\begin{claim}
Диаметр фигуры --- максимальное расстояние между парами опорными прямыми.\end{claim}
\begin{proof}
Обозначим диаметр через $AB$, построим для этого прямые $L_{1}$
и $L_{2}$, перпендикулярные $AB$ и доведем их до опорных прямых.
Тогда расстояние не уменьшится
\end{proof}
Теперь можно заняться построением алгоритма (методом вращающих калиперов)

Перебираем пары перпендикулярных опорных прямых: обозначим прямые
через $L_{1}$ и $L_{2}$ на угол, равный $min(\alpha,\beta)$, и
ищем ма $max(A_{i},B_{i})$ по таким точкам. В итоге, будет $O(n)$
вращений в время работы --- $O(n)$.
\begin{lyxalgorithm}
Поиск накрывающего прямоугольника минимального периметра.

Рассмотрим на данном чертеже сумму $P_{1}=AE_{1}+E_{1}B=AB\cdot(\sin(\alpha_{1})+\cos(\alpha_{1}))=AB\cdot(\sin\alpha_{1}+\sin(\alpha_{1}+\frac{\pi}{2}))=AB\cdot\sqrt{2}\cdot\sin(\alpha_{1}+\frac{\pi}{4})$
--- выпуклая функция на отрезке $[0,\frac{\pi}{2}]$. Заметим, что
сумма $P_{1}+P_{2}+P_{3}+P_{4}$ --- выпуклая функция, где $\alpha_{i}=\alpha+c_{i}$,
$\alpha$ --- угол поворота прямоугольника. Тогда $\min(P_{1}+P_{2}+P_{3}+P_{4})$
достигается на границе диапазона $\alpha$.

Научимся выполнять алгоритм при помощи данной идеи. Будем поворачивать
наш прямоугольник на минимально возможный угол (при этом сохраняется
инвариант: одна из сторон многоугольника лежит на границе прямоугольника).
При пересчете можно учитывать только один угол.

В начале алгоритма возьмем крайние точки (самая нижняя, самая левая,
самая верхняя, самая правая). Алгоритм заканчивает свою работу, когда
уже будет встречена исходная точка или произойдет суммарный оборот
на $90^{\circ}$.

\definecolor{uuuuuu}{rgb}{0.26666666666666666,0.26666666666666666,0.26666666666666666} \definecolor{qqqqff}{rgb}{0.,0.,1.} \begin{tikzpicture}[line cap=round,line join=round,>=triangle 45,x=0.7745539087955416cm,y=0.7445597938763541cm] \clip(-8.849784620469732,-5.911934373717655) rectangle (16.971529781132986,7.518820392044862); \draw (-1.6072424645386667,2.3028980562352124)-- (0.09487777691238504,2.6836354786650523); \draw (0.09487777691238504,2.6836354786650523)-- (1.8417906562963593,2.3252943752016733); \draw (1.8417906562963593,2.3252943752016733)-- (2.1553391218268163,0.44400358201893486); \draw (2.1553391218268163,0.44400358201893486)-- (2.1105464838938937,-0.8773792370022744); \draw (2.1105464838938937,-0.8773792370022744)-- (-0.6889933869137572,-1.1461350645998085); \draw (-0.6889933869137572,-1.1461350645998085)-- (-1.4728645507398996,0.13045511648847843); \draw (-1.6072424645386667,2.3028980562352124)-- (-1.4728645507398996,0.13045511648847843); \draw (-0.5435205682953986,3.862840450111788)-- (-2.8533656362112816,0.14567255935974732); \draw [domain=-8.849784620469732:16.971529781132986] plot(\x,{(--12.897760651625692-2.309845067915883*\x)/3.717167890752041}); \draw [domain=-8.849784620469732:16.971529781132986] plot(\x,{(--10.94292016626764--3.717167890752041*\x)/2.309845067915883}); \draw [domain=-8.849784620469732:16.971529781132986] plot(\x,{(-9.871865725151505--3.717167890752041*\x)/2.309845067915883}); \draw [domain=-8.849784620469732:16.971529781132986] plot(\x,{(--5.851844437184826--2.309845067915883*\x)/-3.717167890752041}); \begin{scriptsize} \draw [fill=qqqqff] (-1.6072424645386667,2.3028980562352124) circle (1.5pt); \draw[color=qqqqff] (-1.5072307621940766,2.516705576094585) node {$A$}; \draw [fill=qqqqff] (0.09487777691238504,2.6836354786650523) circle (1.5pt); \draw[color=qqqqff] (0.03776494548475908,3.0062091666462933) node {$B_1$}; \draw [fill=qqqqff] (1.8417906562963593,2.3252943752016733) circle (1.5pt); \draw[color=qqqqff] (1.9498883460773777,2.5320025632993257) node {$B$}; \draw [fill=qqqqff] (2.1553391218268163,0.44400358201893486) circle (1.5pt); \draw[color=qqqqff] (2.286422064581678,0.7116610859351574) node {$D_1$}; \draw [fill=qqqqff] (2.1105464838938937,-0.8773792370022744) circle (1.5pt); \draw[color=qqqqff] (2.225234115762715,-0.6650677624915243) node {$C$}; \draw [fill=qqqqff] (-0.6889933869137572,-1.1461350645998085) circle (1.5pt); \draw[color=qqqqff] (-0.5894115299096199,-0.9251165449721197) node {$D$}; \draw [fill=qqqqff] (-1.4728645507398996,0.13045511648847843) circle (1.5pt); \draw[color=qqqqff] (-1.369557877351408,0.34453339302137564) node {$G$}; \draw [fill=qqqqff] (-0.5435205682953986,3.862840450111788) circle (1.5pt); \draw[color=qqqqff] (-0.40584768345272837,4.12288923259238) node {$E_1$}; \draw [fill=qqqqff] (-2.8533656362112816,0.14567255935974732) circle (1.5pt); \draw[color=qqqqff] (-2.7156927513686115,0.40572134184033926) node {$E_4$}; \draw[color=black] (-6.096326923616361,7.411741481611675) node {$i$}; \draw[color=black] (1.7969184740299682,7.411741481611675) node {$j$}; \draw[color=black] (7.028488098051373,7.411741481611675) node {$k$}; \draw[color=black] (-8.727408722831804,3.7251675652691163) node {$l$}; \draw [fill=uuuuuu] (1.2101950339693757,-2.3262891862185477) circle (1.5pt); \draw[color=uuuuuu] (1.3686028322972215,-2.1182815469419105) node {$E3$}; \draw [fill=uuuuuu] (3.4714237133080434,1.3126417348363857) circle (1.5pt); \draw[color=uuuuuu] (3.6019629641893998,1.5682923694006483) node {$E_2$}; \end{scriptsize} \end{tikzpicture}
\end{lyxalgorithm}

\begin{lyxalgorithm}
Поиск накрывающего прямоугольника минимальной площади

Будем использовать схожую идею, что и в предыдущем алгоритме. Вычислим
площадь ``опорного'' прямоугольника:

$S=AC\cdot\cos\gamma_{1}\cdot BD\cdot\cos\gamma_{2}=\frac{1}{2}AC\cdot BD\cdot(\cos(\gamma_{1}-\gamma_{2})+\cos(\gamma_{1}+\gamma_{2}))=\frac{1}{2}AC\cdot BD\cdot(cos\varphi+cos\psi)$,
где $\varphi=const$, $pi\le\psi=c_{1}+c_{2}+2\alpha\le\pi$. Таким
образом, $S$ --- выпуклая функция, и можно построить аналогичный
алгоритм.
\end{lyxalgorithm}

\begin{lyxalgorithm}
Обход граней плоского графа.

Даны координаты вершин и список ребер. Найдем все грани плоского графа.

Для начала докажем следующую теорему:\end{lyxalgorithm}
\begin{thm}
(Эйлер) Для планарного графа $G$ выполнено соотношение: $v+f-e=2$,
где $v$ --- количество вершин графа $G$, $f$ --- количество ребер
графа $G$, $e$ --- количество ребер графа $G$.\end{thm}
\begin{proof}
Доказывается тривиальной индукцией с применением леммы Жордана.
\end{proof}
Ход алгоритма:
\begin{enumerate}
\item Сортируем все ребра в каждой вершине по полярному углу (по теореме
Эйлера данный шаг выполняется за $O(v\log v)$ операций).
\item Выполняем поиск очередной грани: если мы прошли по ребру $\overrightarrow{ab}$,
то ищем следующее ребро из данной вершины $b$ после ребра $ba$.
При этом будем обратное ребро $ba$ класть в очередь. Таким образом,
если начать строить очередную грань по ребру из очереди, то обход
граней будет идти в порядке возрастания удаленной от первой грани. 
\end{enumerate}
Заметим, что данный алгоритм позволяет на сфере найти наикратчайший
путь по ребрам грани. Но на плоскости существует внешняя грань, которая
не позволяет уже утверждать данное.
\begin{lyxalgorithm}
Поиск внешней грани плоского графа.

Чтобы найти внешнюю грань, необходимо выполнить данные действия:\end{lyxalgorithm}
\begin{enumerate}
\item Найти крайнюю точку множества (в нашем случае, нижнюю левую точку).
\item Берем ребро с минимальным полярным углом и повторяем данный шаг до
тех пор, не прошли ли мы в исходную точку.\end{enumerate}
\begin{lyxalgorithm}
Проверка, является ли грань внешней?

Можно предоставить два способа, судя по исходным идеям:\end{lyxalgorithm}
\begin{enumerate}
\item Вычислить сумму углов у грани с $n$ вершинами: если сумма равна $\pi(n-2)$,
то грань является внутренней, если сумма равна $\pi(n+2)$, то грань
является внешней.
\item Вычислить ориентированную площадь данного многоугольника по следующей
формуле: $\sum(p_{i+1}.x-p_{i}.x)*\left(\frac{p_{i+1.}y+p_{i}.y}{2}\right)$,
и по знаку данной суммы можно ответить на поставленный вопрос.
\end{enumerate}
\bigskip


\section{$\mathsection33$. Сумма Минковского }
\begin{defn}
Суммой Минковского двух фигур $E$ и $F$ называется множество $G=E\oplus F=\{p+r\,|\,p\in E,r\in F\}$.\end{defn}
\begin{example}
Сумма двух точек на плосости есть точка.
\end{example}

\begin{example}
Сумма точки и фигуры $F$ есть фигура $F$.
\end{example}

\begin{example}
Сумма двух отрезков есть параллелограмм.
\end{example}

\begin{example}
Сумма круга и квадрата с центром в одной точке есть закругленный прямоугольник.
\end{example}

\begin{thm}
Обозначим через $E$, $F$ --- выпуклые мноугольники с $m$ и $n$вершинами
соответственно. Тогда $G=E\oplus F$ является выпуклым многоугольником
с не более, чем $m+n$ вершинами.\end{thm}
\begin{proof}
Рассмотрим некоторое направление $\overrightarrow{e}$ и посмотрим
крайнюю точку множества $G$ --- она будет складываться из крайней
точки $E$ и крайней точки $F$. Поэтому можно посмотреть на нормаль
к ребру множества $E$ и показать, что для любой точки $K\in F$ будет
являться крайним ребром (в обратную сторону все работает аналогично).
Осталось обработать случай параллельных ребер: тогда их сумма будет
крайним ребром.
\end{proof}
Из доказательства данной теоремы можно придумать следующий:
\begin{lyxalgorithm}
Алгоритм построения суммы Минковского двух выпуклых многоугольников.

Ход алгоритма:\end{lyxalgorithm}
\begin{enumerate}
\item Берем крайние левые точки в множествах $E$ и $F$. Обозначим их через
$A_{1}$ и $B_{1}$ соответственно. Строим точку $C_{1}=A_{1}+$$B_{1}$.
\item Среди следующих отрезков $A_{1}A_{2}$ и $B_{1}B_{2}$ выбираем отрезок
с наименьшим углом (предположим, что выбран отрезок $A_{1}A_{2}$).
Тогда надо добавить данный отрезок к $C$, и переместить точку $A_{1}\rightarrow A_{2}$
(если прямые параллельны, то надо продвинуть сумму точек).
\end{enumerate}
Данный алгоритм работает за $O(N)$, где $N$ --- количество вершин
в $E$ и $F$.
\begin{lyxalgorithm}
Определить, пересекаются ли два выпуклых многоугольника?

Алгоритм очень прост: отразим один относительно начала координат,
и если сумма Минковского содержит точку $0$. (Проверку можно осуществлять,
к примеру, таким образом: векторы $\overrightarrow{p_{i}p_{i+1}}$и
$\overrightarrow{p_{i}0}$ всегда образуют правый поворот или всегда
образуют левый поворот).
\end{lyxalgorithm}

\begin{problem}
Есть диван и робот, которые имеют форму выпуклого многоугольника.
Определить ГМТ точек центра робота $R$, где он может оказаться.

Заметим, что ГМТ ограничивает некоторый многоугольник, который сильно
похож на сумму Минковского $D$ и $R$ (где через $D$ обозначается
диван). Что происходит, когда робот пересекает диван? Тогда для вектора
$\overrightarrow{x}$ выполнено соотношение: $R+\overrightarrow{x}\cap D\ne\varnothing$.
Значит, существуют такие $\overrightarrow{r}\in R$, $\overrightarrow{d}\in D$,
такие что $\overrightarrow{r}+\overrightarrow{x}=\overrightarrow{d},$
что равносильно $\overrightarrow{x}=\overrightarrow{d}-\overrightarrow{r}$.
В итоге, $X=D\oplus(-R)$.

\bigskip
\end{problem}

\section{$\mathsection34$. Метод сканирующей прямой}
\begin{problem}
Задача ``Кассы''. Для каждой кассы известно время открытия и время
закрытия касс. Надо найти промежуток времени, в который кассы работают
одновременно. Таким образом, необходимо найти отрезок, в который работает
хотя бы одна касса. 

Можно рассматривать только началы и концы касс, и считать количество
работающих в данный момент количество касс. Значит, надо найти периоды
времени, в которые количество работающих касс равно количеству касс.
\end{problem}
На задаче, рассмотренной выше, можно сформулировать идею метода сканирующей
прямой: есть некоторый набор событий, на каждое из которых можно реагировать
и решать определенные задачи.

Рассмотрим некоторые задачи вычислительной геометрии, которые решаются
при помощи данного метода.
\begin{problem}
Поиск наибольшего креста. На плоскости расположены вертикальные и
горизонтальные отрезки. Найти 2 пересекающихся отрезка с максимальной
суммой длин.

Обрабатываем события:\end{problem}
\begin{enumerate}
\item Начало горизонтального отрезка.
\item Конец горизонтального отрезка (в первом и втором случаях надо изменить
состояние структуры данных).
\item Появление вертикального отрезка (среди всех открытых горизонтальных
отрезков надо найти пересекающимися с ними и ищем самый длинный из
них, чтобы попытаться обновить ответ). Заметим, что открытые горизонтальные
отрезки, пересекающиеся с данным, имеют последовательный диапазон.
Для этого можно использовать дерево отрезков (надо хранить отображение
из горизонтального отрезка в индекс в дереве отрезков).
\end{enumerate}
Таким образом, каждая операция будет обрабатываться за $O(\log N)$
времени.
\begin{rem}
Можно в качестве структуры для решения данной задачи можно использовать
декартово дерево (надо хранить $y$-координату, $\max$ на отрезке
и приоритете в каждом узле). Можно еще использовать $splay$-дерево.\end{rem}
\begin{problem}
Подсчет площади объединения прямоугольников на плоскоти.
\end{problem}
Рассмотрим следующие события:
\begin{enumerate}
\item Начало прямоугольника.
\item Конец прямоугольника.
\end{enumerate}
Как производится обработка события? Надо добавлять площадь объединения
отрезков при переходе от одного события к другому. Для того, чтобы
найти объединение отрезков, можно воспользоваться сканирующей прямой.
Занумеруем все начала и концы. В дереве отрезков будем хранить количество
минимумов на отрезке и сам минимум (и нам отстанется проссумировать
количество минимумов, если этот минимум равен 0, можно воспользоваться
отложенными операциями).
\begin{problem}
Поиск набора пересекающихся отрезков на плоскости (надо проверять
два соседних отрезка на порядок их изменения, и считать текущую позицию
изменения отрезков).

\bigskip
\end{problem}

\section{$\mathsection35$. $K-d$ дерево}

$K$-d дерево разбивает множество точек на вертикальные и горизонтальные
прямоугольники.
\begin{lyxalgorithm}
Построение $K$-d дерева. 

Разобьем множество точек (если их больше 1) в поддереве вертикальной
или горизонтальной прямой по медиане (чередуем горизонтальные и вертикальные
направления) (слева --- не больше медианы, справа --- больше). В узлах
дерева будут храниться проведенные прямые, а в листьях будут храниться
точки (когда размер поддерева равен 1).

Заметим, что количество листьев равно $O(n)$, а глубина дерева $O(\log n)$.
Таким образом, размер дерева равен $O(n)$, а построение данного алгоритма
будет происходить за $O(n\log n)$, если медиану искать за $O(n)$.\end{lyxalgorithm}
\begin{problem}
Отвечать на запросы вида нахождения всех точек из прямоугольника $R$
на плоскости.\end{problem}
\begin{lyxcode}
def~search($v$,~$R$):
\begin{lyxcode}
if~v~==~Leaf:
\begin{lyxcode}
//check~and~give~result
\end{lyxcode}
if~$v.left\cap R\ne\varnothing$:
\begin{lyxcode}
search(v.left,~$R$)
\end{lyxcode}
if~$v.right$$\cap$$R$~$\ne\varnothing$:
\begin{lyxcode}
search(v.right,~$R$)
\end{lyxcode}
\end{lyxcode}
\end{lyxcode}
Обозначим через $Q(n)$ число регионов в поддереве из $n$вершин,
которые могут пересекать прямую $r$(построенная по ребру многоугольника).
Так как мы делим на следующем ходу в другом направлении, то получим,
что $Q(n)=2+2*Q(\frac{n}{4})$, (ибо с каждой стороны могут пересекать
прямую $r$). Из этого следует, что $Q(n)=O(\sqrt{n})$. В $k$-мерном
случае, получаем $Q(n)=2^{k-1}+2^{k-1}Q(\frac{n}{2^{k}})$, из чего
можно получить оценку $Q(n)=O(n^{1-\frac{1}{k}})$.
\begin{problem}
Поиск ближайшей точки к данной на плоскости

Будем использовать dfs, который начинает обход из лучшего поддерева.
Когда доходим до листа, то обновляем минимальное расстояние. При этом,
если понятно, что расстояние заведомо не обновляется, то можно не
заходить в ту часть дерева.
\end{problem}
Алгоритм работает в среднем хорошо, но есть анти-тест, в котором все
точки находятся на одинаковом расстоянии от центра.

\bigskip


\section{$\mathsection36$. Триангуляция Делоне}
\begin{defn}
Обозначим через $V$ --- некоторое множество точек на плоскости. Триангуляцией
Делоне называется такая триангуляция плоскости, что для любого треугольника
из триангуляции его описанный круг содержит только вершины треугольника.

Для построения триангуляции будем добавлять по одной точке. Будем
считать, что никакие 4 точки не лежат на одной окружности, тогда триангуляция
будет единственной.\end{defn}
\begin{claim}
(Критерий Делоне) Ребро $AB$ принадлежит триангуляции Делоне, согда
существует окружность с хордой $AB$, внутренность которой не содержит
других точек триангуляции.\end{claim}
\begin{proof}
Необходимость. Если ребро принадлежит триангуляции, то тогда существует
треугольник, который содержит данное ребро, и малым шевелением окружности
получим требуемое.

Достаточность. Если не существует такой окружности, то тогда существует
ребро $CD$, которое отделяет точки $A$ и $B$. Тогда можно понять,
что сумма углов четырехугольника $ABCD$ меньше $360^{\circ}$.\end{proof}
\begin{defn}
Ребро $AB$ называется хорошим в некоторой триангуляции, если 2 смежных
с ней треугольника подчиняются условию Делоне\end{defn}
\begin{claim}
Все ребра в триангуляции $Tr$ хорошие, согда $Tr$ является триангуляцией
Делоне.\end{claim}
\begin{proof}
Достаточность очевидна.

Необходимость. Предположим, что существует треугольник $ABC$ и точка
$E$, что $E$ лежит в описанном круге треугольника $ABC$. При этом
треугольник $ABE$$\notin Tr$, ибо тогда ребро $AB$ не является
хорошим. Тогда если точка $D$ образует с $AB$ треугольник из триангуляции,
то она лежит вне описанного круга треугольника $ABC$. Тогда $\angle BEA\text{>}\angle BDA$,
так как точка $E$ лежит внутри, а точка $D$ --- снаружи. Значит
точка $E$ принадлежит описанному кругу треугольника $ABD$. Поэтому
$\angle BEA<\angle BED$, и этот угол будет возрастать, что и приводит
к противоречию.\end{proof}
\begin{lyxalgorithm}
Построение триангуляции Делоне.

Будем строить триангуляцию итеративным образом. Рассмотрим три варианта:\end{lyxalgorithm}
\begin{enumerate}
\item $v_{i}\in\triangle ABC$. Ребра $v_{i}A$, $v_{i}B$, $v_{i}C$ будут
хорошими по критерию Делоне. Действительно, построим окружности, содержащие
только ребра $v_{i}A$, $v_{i}B$ и $v_{i}C$. Поэтому добавим их
в триангуляцию, а с ребрами $AB$, $BC$ и $AC$ поступим следующим
образом: если новый круг содержит точку, смежную с труегольником $ABC$,
то произведем операцию $flip$: замену ребра в новом четырехугольнике
на противоположные. Далее надо проверить новые противоположные ребра
$AX$ и $BX$. Суммарное количество ребер будет линейно, но позже
будет доказано, что количество $flip$-ов будет линейно.
\item $v_{i}\in AB$. Обозначим смежные треугольники через $ABD$ и $ABC$.
Тогда ребра $Av_{i}$, $Bv_{i},$ $v_{i}C$ и $v_{i}D$ --- хорошие
по критерию Делоне. Аналогичным образом можно будет запускать $flip$
для ребер $AB$, $BC$, $CD$, $AD$.
\item $v_{i}$ лежит вне всех треугольников --- рассмотрим огромный треугольник,
а затем выкидываем лишние ребра.\end{enumerate}
\begin{lyxalgorithm}
Построение минимального остовного дерева на плоскости.
\begin{claim}
Cамое легкое ребро разреза $S$ и $V\backslash S$ принадлежит триангуляции
Делоне.\end{claim}
\begin{proof}
Предположим противное. Тогда рассмотрим окружность с диаметром данного
ребра. По критерию Делоне, существует точка внутри окружности, и найдется
меньшее расстояние в разрезе.
\end{proof}
\end{lyxalgorithm}
Для существования триангуляции Делоне необходима проекция плоскости
на параболоид (можно почитать в литературе).

В алгоритме Воронова в среднем на одно добавление точки приходиться
около 3 выполнений операции $flip$ . Так как $K-d$ дерево работает
в среднем за $O(\log n)$, то триангуляция Делоне (при локализации
треугольника), работает за $O(N\log N)$ (в худшем случае эта вещь
работает за $O(N^{2})$).
\begin{lyxalgorithm}
Построение триангуляции Делоне методом ``разделяй и властвуй''

Разбиваем множество пополам вертикальной прямой (если точек больше
12, иначе действуем руками). Далее их надо объединить. Для этого мы
смотрим самый нижний отрезок, соединяющий две части (он будет стартовым
отрезком). Строить новый отрезок будем следующим образом: надуваем
окружность, до содержания одной из точек выпуклой оболочки (то есть,
если $AB$ --- текущий отрезок, то надо выбрать такую точку $C$,
которая находится выше отрезка $AB$, при этом $\angle ACB$ минимален).
При этом возможны два случая: точка $C$ лежит на границе одного из
двух выпуклых многоугольников (тогда просто добавим этот отрезок и
перейдем далее). Оказывается, что $CA$ принадлежит триангуляции Делоне,
ибо окружность, описанная около треугольника $ABC$, не содержит других
точек, поэтому можно воспользоваться критерием Делоне. Осталось только
удалить все ребра, которые пересекают отрезки $AC$ и $CB$, ибо при
соединении данные точки будут использовании. Шаг заканчивается в том
случае, когда отрезок оказался верхним.

Шаг алгоритма работает за $O(N)$, ибо каждое ребро триангуляции Делоне
(которая является планарным графом) будет просмотрено не более двух
раз. В итоге, алгоритм работает за $O(N\log N)$ детерминированным
образом.
\end{lyxalgorithm}
\bigskip


\section{$\mathsection37.$ Диаграмма Вороного}

Задача: для каждой точки на плоскости (множество точек конечно) надо
понять, какая точка из множества является ближайшей.
\begin{defn}
Диаграммой Вороного называется разбиение конечного множества $X$
на ячейки $X_{i}$ таким образом, что $X_{i}=\{y\,|\,\rho(x_{i},y)\rightarrow min\}$.
\end{defn}
Существует тривиальный алгоритм за $O(N^{4})$, который просматривает
серединные перпендикуляры любой пары точек, а затем их пересекает.
\begin{claim}
Ребро $AB$ принадлежит триангуляции Делоне тогда и только тогда,
когда ячейки $C(A)$ и $C(B)$ диаграммы Воронова имеют общую границу
(хотя бы точку).\end{claim}
\begin{proof}
Заметим, что если рассмотреть пересечение ячеек диаграммы Воронова,
то эта точка будет центром окружности многоугольника, которые создают
данные ячейки.

\textit{Достаточность.} Существует точка на серединном перпендикуляре,
окружность которого содержит только необходимые точки. Следовательно,
по критерию Делоне, ребро $AB$ будет принадлежать триангуляции Делоне.

\textit{Необходимость. }По критерию Делоне строим окружность с хордой
$AB,$ не содержащей других точек. Тогда её центр принадлежит границе
ячеек $C(A)$ и $C(B)$.\end{proof}
\begin{lyxalgorithm}
Построение диаграммы Вороного (алгоритм Форчуне)

Будем использовать метод сканирующей прямой. Рассмотрим для каждой
из точек ГМТ, таких что расстояния до прямой и до точки совпадают
(как известно, данное ГМТ является параболой).

Рассмотрим несколько случаев событий:
\begin{enumerate}
\item Появление новой точки (пересечение серединных перпендикуляров будет
лежать правее --- есть проблема, нельзя сразу обработать). Поэтому
надо просмотреть события, которые могут быть связаны со смежными серединными
перпендикулярами (изначально добавится пересечение серединных перпендикуляров
$O$ треугольника $ABC$, где $A$ --- добавленная точка), и если
они идут раньше, то необходимо удалить событие с точкой $O$.
\item Пересечение серединных перпендикуляров (аннигиляция параболы). В итоге,
пары смежных к данной ячейке пересекаются. Надо добавить новый серединный
перпендикуляр двух ``встреченных'' точек, открытый в необходимую
сторону, и добавляем в пересечение ожидаемых ребят (которые были соседними
со встреченными вершинами).
\item Пересечение хотя бы трех серединных перпендикуляров --- добавление
всех новых серединных перпендикуляров во встрече. 
\end{enumerate}
\end{lyxalgorithm}
Время работы алгоритма состоит из сортировки точек $O(N\log N)$,
и поиск локализации событий при хранении в сете выполняется в сумме
за $O(N\log N)$.

\bigskip


\part{Параллельные алгоритмы}


\section{$\mathsection38$. Потоки}

Изначально процессоры уже затачивались на многозадачности, при этом
выполнялся процесс \textit{task scheduling, }в котором происходило
переключение контекста (было некоторое время на смену). Таким образом,
уже было писать многопоточные программы. При наличии нескольких ядер
на машине, можно уменьшить накладные расходы (можно перераспределять
процессы). В Windows есть 7 приоритетов процессов и 7 приоритетов
потоков (в сумме их 35).

У процессов ресурсы не зависимы, а у потоков есть одно общее виртуальное
адресное пространство (в 32-битных системах под код и данные отдается
ровно 3 Гб информации, остальные используются на адрес ядра). В начале
есть участок из 64 кб, отведенный на нулевой указатель (в начале участка
ядра есть аналогичное пространство). В $x86$ используется 4 Тб виртуального
адресного пространства (при записи связывается с реальным адресным
пространством). 

Если на машине есть одно ядро, то не надо синхронизировать доступ
(raise-condition не будет). У каждого потока есть свой стек. По умолчанию,
размер стека в Windows равен 1 Мб. Перед распараллеливанием можно
узнать информацию о возможности распаллеливания процессов (количество
ядер и возможное количество запускаемых потоков).

Многопоточность необходима для:
\begin{itemize}
\item Ускорения работы программы
\item Разделения задач (отделение от интерфейса, к примеру). Можно реализовать
механизм call-back-ов (прогресс о выполнении потока).
\end{itemize}
Рассмотрим $API$ для использования в $STL\ \mbox{C++}11$ . В 11-м
стандарте появился заголовочный файл $thread$. Функция инициализации
потока равнозначна точке входа (вызываются конструкторы статических
полей класса перед main, после вызова --- вызываются деструктора).
Поток завершает свою работу, когда функция потока закончит свою работу,
либо когда функция $main$ завершит работу, либо когда вызываются
$terminate$ процессы (искусственное прерывание потоков). К примеру,
если есть unhandled exception, то тот вызывает terminate.
\begin{lyxcode}
\#include~<thread>

void~doSmth();

int~main()~\{
\begin{lyxcode}
std::thread~t(doSmth);~//инициализация~потока

t.join();~//~ожидание~завершения~выполнения~функции~потока
\end{lyxcode}
\}
\end{lyxcode}
Как можно заметить, что класс $thread$ не является шаблонным, но
его конструктор является мощным шаблоном (можно передать функтор,
который имеет оператор круглые скобки).

Как это выглядеть?
\begin{lyxcode}
class~BackgroundTask~\{

public:
\begin{lyxcode}
void~operator()()~\{
\begin{lyxcode}
...

doSmth...
\end{lyxcode}
\}
\end{lyxcode}
\}

BackgroundTask~task;

std::thread~t(task);

std::thread~t2(BackGroundTask());

std::thread~t3({[}{]}~\{
\begin{lyxcode}
doSmth...;~//~лябмбды~видят~локальные~параметры~(но~появляется~невалидность~при~создании~нового~потока)

//~но,~скорее~всего,~можно~передать~параметры~по~значению
\end{lyxcode}
\});
\end{lyxcode}
Существуют две возможности управления потоком: join и detach (отвязать
объект thread от потока). Если был вызван деструктор $thread$, а
поток не завершил работу и приаттачен к сущности std::thread, то вызывается
std::terminate.
\begin{lyxcode}
bool~thread::joinable();~//~возвращает~true,~если~поток~жив~и~присоединен
\end{lyxcode}
Напишем плохой код:
\begin{lyxcode}
struct~Functor~\{
\begin{lyxcode}
int\&~data;

Functor(int\&~\_data):~data(\_data)~\{\}

void~operator()~()~\{
\begin{lyxcode}
for~(int~i~=~0;~i~<~1000000;~++i)~\{
\begin{lyxcode}
data~=~i;
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
\}

void~Oops()~\{
\begin{lyxcode}
int~localData~=~0;

Functor~f(localData);

std::thread~t(f);

t.detach();
\end{lyxcode}
\}
\end{lyxcode}
В данном коде есть проблема: порча стека, меняя данные в нем или можно
получить access violation.
\begin{lyxcode}
void~notOops()~\{
\begin{lyxcode}
int~localData~=~0;

Functor~f(localData);

std::thread~t(f);

try~\{
\begin{lyxcode}
doSmth();~//~без~обработки~поток~получает~terminate
\end{lyxcode}
\}~catch~(...)~\{
\begin{lyxcode}
t.join();

throw~...;
\end{lyxcode}
\}

t.join();
\end{lyxcode}
\}
\end{lyxcode}
Лучше всего писать так (идеология RAII --- Resouce Acquisiton Is Initializing,
гарантия освобождения ресурсов в деструкторе)
\begin{lyxcode}
class~ThreadGuard~\{

public:
\begin{lyxcode}
ThreadGuard(std::thread\&~\_t):~t(\_t)

\textasciitilde{}ThreadGuard()~\{
\begin{lyxcode}
if~(t.joinable())~\{
\begin{lyxcode}
t.join();
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
private:
\begin{lyxcode}
std::thread\&~t;

ThreadGuard(const~ThreadGuard\&~other)~=~delete;~//запрет~конструктора~копирования

ThreadGuard\&~operator~=(const~ThreadGuard\&~other)~=~delete;~//~запрет~присваивания,~
\end{lyxcode}
\}

void~notOopsNeo()~\{
\begin{lyxcode}
int~localData~=~0;

Functor~f(localData);

std::thread~t(f);

ThreadGuard~g(t);

doSmth();
\end{lyxcode}
\}
\end{lyxcode}
В поток можно передавать параметры, они передаются по значению.
\begin{lyxcode}
template<class~F,~class~...~Args>

std::thread::thread(F,~Args...)
\end{lyxcode}
Напишем пример передачи параметров в thread (с косяком):
\begin{lyxcode}
void~func(const~string\&~s)~\{
\begin{lyxcode}

\end{lyxcode}
\}

void~oopsK(int~param)~\{
\begin{lyxcode}
char{*}~buffer~=~new~char{[}1024{]};

sprintf(buffer,~``\%i'',~param);

std::thread~t(func,~buffer);~//~buffer~будет~скопирован~как~указатель,~а~преобразование~к~string

//будет~выполняться~в~контексте~другого~потока

t.detach();

delete{[}{]}~buffer;~//~плохо,~ибо~поток~он~передаст~указатель~на~разрушенную~область~памяти
\end{lyxcode}
\}
\end{lyxcode}
Именно поэтому многопоточные программы сложно отлаживать (во-первых,
контроль ресурсов, во-вторых, слежение для блокировки). Лучше написать
так:
\begin{lyxcode}
std::thread~t(func,~std::string(buffer));
\end{lyxcode}
Далее рассмотрим Interlock-functions (atomic functions), который используется
для счетчика ссылок.

Информация о потоках разрешается при помощи функции std::hardware\_concurrency()
--- статическая функция, возвращающая действительное число ядер. Потоки
можно идентифицировать (
\begin{lstlisting}
std::thread::id myId = t.get_id()
\end{lstlisting}
). Также в Windows можно использовать следующие функции: id потока
(unsigned int), HANDLE потока (объект ядра, с которыми работают Windows-функции,
можно распознать объект ядра по 32 битам информации).


\section{$\mathsection39$. Разделение данных между потоками}

Рассмотрим способы разделения данных между потоками. Если данные доступны
только для чтения, то их разделять не надо. Если данные доступны для
записи, то могут возникнуть проблемы.

К примеру, рассмотрим операцию удаления из двусвязного списка: 1)
надо сначала найти удалить элемент $x$; 2) затем надо перенаправить
указатели; 3) выполнить delete. В итоге, если второй поток желает
работать в середине удаления элемента из списка, то возникнут проблемы
(список становится невалидным). 

Возникает понятие \textit{``race condition''} (гонка за ресурсами).
Как можно бороться с race condition:
\begin{enumerate}
\item Защищенный доступ данных.
\item Изменить структуру таким образом, чтобы ее изменение состоит из набора
независимых изменений (Lock-free programming)
\item Транзакционная работа: есть набор изменений, а затем происходит либо
commit, либо rollback (если был конфликт со стороны другого потока)
на все операции.
\end{enumerate}
Мы будем выполнять блокировки. Разобьем кусок на блоки и пометим его
таким образом, чтобы его мог выполнять только один поток. Надо создать
mutex (mutually exclusive).
\begin{lyxcode}
mutex.lock()

//~some~code

mutex.unlock()

//~есть~mutex.try\_lock(),~который~пытается~зайти
\end{lyxcode}
Этот механизм использует стандартные объект ядра.

В WinAPI есть CRITICAL\_SECTION и методы EnterCriticalSection, TryCriticalSection
и LeaveCriticalSection (в одном процессе), также можно создать мютекс:
\begin{lyxcode}
HANDLE~CreateMutex(...,~name)

HANDLE~OpenMutex(...,~name)

//можно~синхронизировать~разные~процессы
\end{lyxcode}
Критическая секция --- это пара из mutex и количество локов (если
локов 0, то идет выполнение, иначе --- режим ожидания). Если unlock
не происходит быстро, то влетающий поток может уйти в спячку надолго.
Чтобы такого не возникало, использовался EnterCritSectionWithSpinCount
(атомарный count).

Чтобы выполнять проверку на то, чтобы выполнить unlock, существует
std::lock\_guard:
\begin{lyxcode}
std::list<int>~myList;

std::mutex~myMutex;

void~addToList(int~value)~\{
\begin{lyxcode}
std::lock\_guard<std::mutex>~guard(myMutex);

myList.push\_back(value);
\end{lyxcode}
\}

//Нельзя~возвращать~всякого~рода~ссылки~на~стек!!
\end{lyxcode}
Напишем потоконезависимый стек:
\begin{lyxcode}
class~thread\_safe\_stack~\{

public:
\begin{lyxcode}
bool~empty()~const;

size\_t~size()~const;

T~pop();~//~not~good~interface

void~pop();

void~push(const~T\&~e);
\end{lyxcode}
private:
\begin{lyxcode}
std::stack<T>~\_internalStack;

std::mutex~m;
\end{lyxcode}
\}
\end{lyxcode}
Но реализация ломается на таком коде:
\begin{lyxcode}
thread\_safe\_stack<int>~s;

if~(!s.empty())~\{
\begin{lyxcode}
const~int~value~=~s.top();

s.pop();

doSmth(value);
\end{lyxcode}
\}
\end{lyxcode}
Проблема состоит в том, что top-ы сработают одновременно, а удаляться
будет другой элемент. Аналогично нельзя возвращать pop по значению.

Напишем исправленный вариант:
\begin{lyxcode}
std::shared\_ptr<T>~pop()~\{
\begin{lyxcode}
std::lock\_guard<std::mutex>~lock(m);

if~(internal\_stack.empty())~throw~empty\_stack.exception();

std::shared\_ptr<T>~res(std::make\_shared<T>~(internal\_stack.top()));

internal\_stack.pop();

return~res;
\end{lyxcode}
\end{lyxcode}
Перейдем к рассмотрению взаимных блокировок (Dead Lock):
\begin{lyxcode}
//~Thread-1

mutexA.lock()

mutexB.lock()

//Thread-2

mutexB.lock()

mutexA.lock()
\end{lyxcode}
Несколько советов:
\begin{enumerate}
\item Блокировать сначала mutexA, а затем только блокировать mutexB
\item Объединить всесозможные блокировки в один класс и выстраивать их иерархию.
\end{enumerate}

\section{$\mathsection40$. Атомарные типы}

В прошлом параграфе была проблема с неатомарностью метода pop() в
стеке. Поэтому воспользуемся atomic типами. В STL C++ 11 они представлены
в виде std::atomic
\begin{lyxcode}
template<class~T>

std::atomic<T>

//some~methods
\end{lyxcode}
Для пользовательских типов определены следующие методы: operator =,
is\_lock\_free(), store(), load(), operator T, exchange, compare\_exchange.
А для примитивных типов есть методы fetch\_add, fetch\_sub, fetch\_add(for
booleans with and), fetch\_or, fetch\_xor. В WinAPI есть аналогичные
interlocked функции: \_InterlockedIncrement, \_InterlockedDecrement,
.... (работают с shared\_ptr).

К примеру, 
\begin{lyxcode}
if(\_InterlockedDecrement(refCount)~==~0)~\{
\begin{lyxcode}
delete~object;
\end{lyxcode}
\}
\end{lyxcode}
Здесь операция декремента работает корректно с shared\_ptr.

\_InterlockedBittestandSet используется в spin-блокировках:
\begin{lyxcode}
while(\_interlockedBittestandSet(flag,~false,~true))~\{
\begin{lyxcode}
//doSmth
\end{lyxcode}
\}из

//unlock

\_InterlockedExchange(flag,~false);
\end{lyxcode}
На очень быстрых действиях лучше использовать interlock-функции, потому
что не происходит связи с mutex, поэтому работает быстрее. std::atomic
в Windows реализован при помощи спин-блокировок. С помощью \_InterlockedCachedCompareExchange
можно реализовать любые арифметические операции.


\section{$\mathsection41$. Спецификации мютексов}

Как было видно, std::mutex не может просто взять и по призыву приостановить
действие lock-а. Поэтому для этого используется std::timed\_mutex:
\begin{lyxcode}
class~std::timed\_mutex~\{
\begin{lyxcode}
lock();

bool~try\_lock();

t<>~bool~try\_lock\_for(const~chrono::duration<...>\&~duration);~//lock~for~this~time

t<>~bool~try\_lock\_until(const~chrono::point\_of\_time<...>\&~p);~
\end{lyxcode}
\}
\end{lyxcode}
Иногда надо делать так, чтобы при попытке записи происходила блокировка.
Для этого используется shared mutex. Что хотят добавить в стандарт
C++: 
\begin{lyxcode}
std::shared\_timed\_mutex~\{
\begin{lyxcode}
lock

try\_хи

try\_lock\_for

try\_lock\_until

//shared-block

lock\_shared()

try\_lock\_shared

...\_for

...\_until
\end{lyxcode}
\}
\end{lyxcode}
В реализации используются семафоры при помощи event-ов.
\begin{example}
DNS-cache\end{example}
\begin{lyxcode}
class~DNSCache~\{
\begin{lyxcode}
std::map<std::string,~dns\_entry>~entries;

mutable~boost::shared\_mutex~m;
\end{lyxcode}
public:
\begin{lyxcode}
dns\_entry~find(const~std::string\&~domain)~const~\{
\begin{lyxcode}
boost::shared\_lock<boost::shared\_mutex>~lock(m)~//~analogue~of~shared~guard

auto~it~=~entries.find(domain);

return~(it~==~entries.end())~?~dns\_entry()~:~it->second;
\end{lyxcode}
\}

void~update\_entry(const~std::string\&~domain,~const~dns\_entry\&~d)~\{
\begin{lyxcode}
std::lock\_guard<boost::shared\_mutex>~g(m);

entries{[}domain{]}~=~d;
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
Предоставим еще один способ работы с блокировками заключается в том,
что все синхронизационные объекты получает свою иерархию (присваивается
уровень иерархии для каждого mutex при помощи топологической сортировки).
Но надо гарантировать во время выполнения, что никакой mutex c меньшим
уровнем не заблокируется перед исходным lock-ом. Поэтому надо написать
иерархический класс, который будет контролировать это дело:
\begin{lyxcode}
class~HierarchicalMutex~\{
\begin{lyxcode}
std::mutex;

static~thread\_local<int>~current\_thread\_level~=~MAX\_INT;

const~int~mutex\_level;

//lock~состоит~из~3~частей:

//~1:~проверка~того,~что~mutex\_level~<~current\_thread\_level);

//~2:~m.lock();

//~3:~prev\_level~=~current\_thread\_level;

//~4:~current\_thread\_level~=~mutex\_level;

//

//~unlock,~разблокировка~происходит~по~транзитивному~замыканию
\end{lyxcode}
\}
\end{lyxcode}
Операционная система представляет API для работы с общим хранением
потоков (причем их число ограничено, порядка 1000). Есть некоторые
методы, которыми можно пользоваться: TLSAlloc, TLSFree, TLSSetValue,
TLSGetValue(index, data) --- WinAPI, и thread\_local в STL C++11.


\section{Events}

Рассмотрим механизм обработки событий. Как это делать при помощи mutex-ов:
\begin{lyxcode}
bool~flag;

std::mutex~m;

void~wait\_for\_flag()~\{
\begin{lyxcode}
std::unique\_lock<std::mutex>~l(m);

while~(!flag)~\{
\begin{lyxcode}
l.unlock();

std::this\_thread::sleep\_for(std::chrono::multiseconds(100));

l.lock();
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
В данном случае проходят очень много времени. Есть в Windows самосбрасывающиеся
и несамосбрасывающиеся события.
\begin{lyxcode}
\#include~<condition\_variable>

std::mutex~m;

std::queue<data\_chunk>~data\_queue;

std::condition\_variable~data\_cond;

void~data\_preparation\_thread()~\{
\begin{lyxcode}
while(hasData())~\{
\begin{lyxcode}
const~data\_chuk~data~=~prepare();

std::lock\_guard<std::mutex>~l(m);

data\_queue.push(data);

data\_cond.notify\_one();
\end{lyxcode}
\}
\end{lyxcode}
\}

void~data\_processing\_thread()~\{
\begin{lyxcode}
while~(true)~\{
\begin{lyxcode}
std::unique\_lock<mutex>~l(m);

data\_cond.wait(l,~{[}{]}\{return~!data\_queue.empty()\});

data\_chunk~data~=~data\_queue.foront();

data\_queue.pop();

l.unlock();

process(data);

if~(is\_last\_chunk(data))~\{
\begin{lyxcode}
return;
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
При этом все хорошо, ибо notify\_one предупреждаем ровно один объект
и извлекаем ровно один объект. Если использовать notifyAll, то проснутся
все потоки, и информация только достанет один элемент, а остальные
не получат данные, и тогда информация будет получать false на wait,
в итоге получится бесконечный цикл на блокировке. Notify\_all полезно
слать тогда, когда надо завершить приложений.

Напишем обработчик заданий, который не зависит от методов синхронизации:
\begin{lyxcode}
\#include~<mutex>

\#include~<condition\_variable>

\#include~<memory>

template~<class~T>

class~ThreadSafeQueue~\{

public:
\begin{lyxcode}
ThreadSafeQueue();

void~push(T~value);

bool~try\_pop(T\&~value);

shared\_ptr<T>~try\_pop();

void~wait\_and\_pop(T\&~value);

shared\_ptr<T>~wait\_and\_pop();
\end{lyxcode}
private:
\begin{lyxcode}
std::mutex~m;

std::queue<T>~data\_queue;

std::condition\_variable~data\_cond;
\end{lyxcode}
\}

template<class~T>

void~ThreadSafeQueue::push(T~newValue)~\{
\begin{lyxcode}
std::lock\_guard<...>~l(m);

data\_queue.push(newValue);

data\_cond.notify\_one();
\end{lyxcode}
\}

template<class~T>

shared\_ptr<T>~ThreadSafeQueue::wait\_and\_pop()~\{
\begin{lyxcode}
std::unique\_lock<...>~l(m);

data\_cond.wait(l,~{[}this{]}~\{return~!data.push.empty();{]}\});

std::shared\_ptr<T>~result~=~std::make\_shared(data\_queue.front());

data\_queue.pop();

return~res;
\end{lyxcode}
\}
\end{lyxcode}

\section{Future, packaged tasks, promise}

Теперь хотим получить результат выполнения задания, ибо у нас есть
объект для отправки заданий. Можно аналогично завести очередь результатов,
но тогда нам надо будет ждать либо всегда, либо периодически. Поэтому
будем использовать future.
\begin{lyxcode}
\#include~<future>

std::future~<T>

std::shared\_future~<T>

int~find\_answer(params...);

int~main()~\{
\begin{lyxcode}
std::future<int>~answer~=~std::async(find\_answer,params...);

//...

std::cout~<\textcompwordmark{}<~answer.get();
\end{lyxcode}
\}
\end{lyxcode}
Если первый параметр --- это функция, то тогда второй, третий аргументы
и т.д. --- параметры функции. Если первый параметр --- std::launch,
то тогда далее передается либо std::launch\_differed -- выполнение
на текущем потоке или std::launch::async -- на отдельном потоке. По
default --- то тогда отдается уже приоритет реализации.

Можно организовывать выполнение заданий через выполнение packaged
task (более гибкое выполнение), его можно перемещать и вызывать много
раз (внутри есть ссылка на вызываемую функцию). Иногда лучше, чтобы
тот участок, запрашивающий данное дело, не должно знать информацию
о задаче. Это можно сделать при помощи класса promise. 

Полагаем, что есть один поток, знающий о соединении с удаленной машиной
и работает с пакетами.
\begin{lyxcode}
struct~data\_packet;

struct~outgoing\_thread;

class~Connection~\{
\begin{lyxcode}
bool~has\_incoming();

bool~has\_outgoing();

data\_packet~incoming();

std::promise<payload\_type>~get\_promise(int~dataId);

outgoing\_packet~top\_of\_outgoing();

void~send(payload);
\end{lyxcode}
\};

void~process\_connections(connections)~\{
\begin{lyxcode}
while(!done)~\{
\begin{lyxcode}
for(connection~in~connections)~\{
\begin{lyxcode}
if~(connection->has\_outgoing\_data())~\{
\begin{lyxcode}
data\_packet~data~=~connection()->outgoing();

data.promise.set\_value(connection->send(data.payload));
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
Данная вещь хороша для отсылки сервера информации (надо сделать такую-то
задачу), outgoing\_data --- знает, что надо отправить на исполнение
задачу. 

Перейдем к обработке исключений:
\begin{lyxcode}
future<double>~f~=~async(square\_root,~-1);

double~y~=~f.get();~//async~сохраняет~исключение,~и~оно~пробрасывается~через~get

double~square\_root(double~x)~\{
\begin{lyxcode}
if~(x~<~0)~\{
\begin{lyxcode}
throw~std::out\_of\_raGnge(``x<0'');
\end{lyxcode}
\}

return~sqrt(x);
\end{lyxcode}
\}


\end{lyxcode}
С packaged task все аналогично. Но в promise все идет немного не так:
\begin{lyxcode}
promise<double>~p;

try~\{
\begin{lyxcode}
p.set\_value(square\_root(data~param));
\end{lyxcode}
\}~catch~(std::exception~e)~\{
\begin{lyxcode}
p.set\_exception(std::current\_exception()~-{}-{}-~std::exception\_ptr);~//задерживает~exception~и~future~разблокируется,

//~и~get~бросит~исключение~в~запрашивающем~потоке
\end{lyxcode}
\}
\end{lyxcode}
Перейдем к вопросу ожидания с нескольких потоков. Для этого есть класс
std::shared\_future::shared\_future<T>(std::future<T>\&\& x), и можно
теперь дожидаться копию объекта, полученного из future. И тогда get()
получит управление. Как сделать так, чтобы остановить все потоки?
Можно передавать по future, чтобы получить на get то, что надо остановить
потоки.

Рассмотрим ThreadPool. Если мы хотим ждать все потоки, то надо прервать
все через некоторое время. Хочется выполнять пул потоков, которые
надо выполнять и сообщать результаты.

Поэтому есть функции submit, которое добавляет задание в очереди.
Рабочий класс:
\begin{lyxcode}
void~worker\_thread()~\{
\begin{lyxcode}
while(!done)~\{
\begin{lyxcode}
std::future<void()>~task;

if~work\_queue.try\_pop(task))~\{
\begin{lyxcode}
task();
\end{lyxcode}
\}~else~\{
\begin{lyxcode}
std::this\_thread::yield();//по~идее,~надо~бы~не~ждать,~а~реализоывать~все~дело~через~event'ы.
\end{lyxcode}
\}
\end{lyxcode}
\}
\end{lyxcode}
\}\end{lyxcode}

\end{document}
